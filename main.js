/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TodoExtendedPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/TodoExtendedView.ts
var import_obsidian = require("obsidian");
var VIEW_TYPE_TODO_EXTENDED = "todo-extended-view";
var TodoExtendedView = class extends import_obsidian.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.searchFilters = {
      text: "",
      page: "",
      priority: "",
      dueDateFrom: "",
      dueDateTo: "",
      hasLinks: null,
      completed: null
    };
    this.panelsState = {
      search: false,
      grouping: false,
      sorting: false
    };
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_TYPE_TODO_EXTENDED;
  }
  getDisplayText() {
    return "Todo Extended";
  }
  getIcon() {
    return "checkmark";
  }
  async onOpen() {
    this.viewContentEl = this.containerEl.children[1];
    this.viewContentEl.empty();
    this.viewContentEl.addClass("todo-extended-view");
    await this.refreshTodos();
  }
  async onClose() {
  }
  async refreshTodos() {
    if (!this.viewContentEl)
      return;
    this.viewContentEl.empty();
    const headerEl = this.viewContentEl.createDiv("todo-extended-header");
    headerEl.createEl("h3", { text: "Todo Extended" });
    const controlsEl = headerEl.createDiv("todo-controls");
    const searchBtn = controlsEl.createEl("button", {
      text: "Filter",
      cls: "todo-control-btn",
      attr: { title: "Search and Filter" }
    });
    searchBtn.addEventListener("click", () => this.toggleSearchPanel());
    const groupingBtn = controlsEl.createEl("button", {
      text: "Group",
      cls: "todo-control-btn",
      attr: { title: "Grouping Settings" }
    });
    groupingBtn.addEventListener("click", () => this.toggleGroupingPanel());
    const sortingBtn = controlsEl.createEl("button", {
      text: "Sort",
      cls: "todo-control-btn",
      attr: { title: "Sorting Settings" }
    });
    sortingBtn.addEventListener("click", () => this.toggleSortingPanel());
    const refreshBtn = controlsEl.createEl("button", {
      text: "Refresh",
      cls: "todo-control-btn",
      attr: { title: "Refresh" }
    });
    refreshBtn.addEventListener("click", () => this.refreshTodos());
    const panelsContainer = this.viewContentEl.createDiv("todo-panels-container");
    const loadingEl = this.viewContentEl.createDiv("todo-loading");
    loadingEl.setText("Loading todos...");
    try {
      const allGroups = await this.plugin.getAllTodos();
      const filteredGroups = this.applySearchFilters(allGroups);
      loadingEl.remove();
      if (filteredGroups.length === 0) {
        const emptyEl = this.viewContentEl.createDiv("todo-empty");
        emptyEl.setText("No todos found");
        return;
      }
      const todosEl = this.viewContentEl.createDiv("todos-container");
      for (const group of filteredGroups) {
        this.renderGroup(todosEl, group);
      }
    } catch (error) {
      loadingEl.setText("Error loading todos");
      console.error("TodoExtended: Error loading todos", error);
    }
  }
  renderGroup(container, group) {
    const groupEl = container.createDiv("todo-group");
    if (this.plugin.settings.groupingCriteria.some((c) => c.enabled)) {
      const headerEl = groupEl.createDiv("todo-group-header");
      headerEl.createEl("h4", { text: group.name });
      headerEl.createEl("span", {
        text: `(${group.todos.length})`,
        cls: "todo-count"
      });
    }
    const listEl = groupEl.createDiv("todo-list");
    for (const todo of group.todos) {
      this.renderTodo(listEl, todo);
    }
  }
  renderTodo(container, todo) {
    const todoEl = container.createDiv("todo-item");
    if (todo.completed) {
      todoEl.addClass("todo-completed");
    }
    if (todo.indent > 0) {
      todoEl.addClass("todo-child");
      if (todo.indent >= 4) {
        todoEl.addClass("todo-child-level-2");
      }
      if (todo.indent >= 8) {
        todoEl.addClass("todo-child-level-3");
      }
    }
    const checkboxEl = todoEl.createEl("input", {
      type: "checkbox",
      cls: "todo-checkbox"
    });
    checkboxEl.checked = todo.completed;
    checkboxEl.addEventListener("change", async () => {
      await this.plugin.toggleTodo(todo.id);
    });
    const contentEl = todoEl.createDiv("todo-content");
    const textEl = contentEl.createDiv("todo-text");
    textEl.setText(todo.displayText);
    textEl.addEventListener("click", () => this.openTodoFile(todo));
    if (todo.linkedNotes.length > 0) {
      const linkedNotesEl = todoEl.createDiv("todo-linked-notes");
      for (const noteName of todo.linkedNotes) {
        const linkBtn = linkedNotesEl.createEl("button", {
          cls: "todo-link-icon"
        });
        linkBtn.innerHTML = "\u{1F517}";
        linkBtn.title = `Open ${noteName}`;
        linkBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          this.openLinkedNote(noteName);
        });
      }
    }
    if (this.plugin.settings.showImages && todo.images.length > 0) {
      const imagesEl = contentEl.createDiv("todo-images");
      if (this.plugin.settings.autoCollapseImages) {
        imagesEl.addClass("todo-images-collapsed");
        const toggleBtn = imagesEl.createEl("button", {
          text: `\u{1F4F7} ${todo.images.length} image${todo.images.length > 1 ? "s" : ""}`,
          cls: "todo-images-toggle"
        });
        const imageContainer = imagesEl.createDiv("todo-images-container");
        toggleBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          imageContainer.toggleClass("todo-images-expanded", !imageContainer.hasClass("todo-images-expanded"));
          toggleBtn.setText(imageContainer.hasClass("todo-images-expanded") ? "\u{1F4F7} Hide images" : `\u{1F4F7} ${todo.images.length} image${todo.images.length > 1 ? "s" : ""}`);
        });
        for (const imagePath of todo.images) {
          const imgEl = imageContainer.createEl("img", {
            cls: "todo-image"
          });
          imgEl.src = imagePath;
        }
      } else {
        for (const imagePath of todo.images) {
          const imgEl = imagesEl.createEl("img", {
            cls: "todo-image"
          });
          imgEl.src = imagePath;
        }
      }
    }
    const metaEl = contentEl.createDiv("todo-meta");
    const fileEl = metaEl.createSpan("todo-file");
    fileEl.setText(todo.file.basename);
    fileEl.addEventListener("click", () => this.openTodoFile(todo));
    if (this.plugin.settings.enableInlineEditing) {
      if (todo.priority !== "none") {
        const priorityEl = metaEl.createSpan("todo-priority clickable-priority");
        priorityEl.addClass(`todo-priority-${todo.priority}`);
        priorityEl.setText(todo.priority.toUpperCase());
        priorityEl.title = "Click to change priority";
        priorityEl.addEventListener("click", (e) => {
          e.stopPropagation();
          this.showPrioritySelector(priorityEl, todo);
        });
      } else {
        const prioritySelector = metaEl.createEl("select", { cls: "todo-priority-selector" });
        const priorities = [
          { value: "none", label: "No Priority" },
          { value: "low", label: "Low" },
          { value: "medium", label: "Medium" },
          { value: "high", label: "High" }
        ];
        priorities.forEach((p) => {
          const option = prioritySelector.createEl("option", { value: p.value, text: p.label });
          if (p.value === todo.priority)
            option.selected = true;
        });
        prioritySelector.addEventListener("change", async () => {
          const newPriority = prioritySelector.value;
          await this.plugin.updateTodoPriority(todo.id, newPriority);
        });
      }
    } else {
      if (todo.priority !== "none") {
        const priorityEl = metaEl.createSpan("todo-priority");
        priorityEl.addClass(`todo-priority-${todo.priority}`);
        priorityEl.setText(todo.priority.toUpperCase());
      }
    }
    const dueDateEl = metaEl.createSpan("todo-due-date clickable-date");
    if (todo.dueDate) {
      const isOverdue = todo.dueDate.isBefore(window.moment(), "day");
      const isToday = todo.dueDate.isSame(window.moment(), "day");
      if (isOverdue) {
        dueDateEl.addClass("todo-overdue");
      } else if (isToday) {
        dueDateEl.addClass("todo-today");
      }
      dueDateEl.setText(todo.dueDate.format(this.plugin.settings.dateDisplayFormat));
    } else {
      dueDateEl.setText("Set due date");
      dueDateEl.addClass("todo-no-date");
    }
    if (this.plugin.settings.enableInlineEditing) {
      dueDateEl.addEventListener("click", (e) => {
        e.stopPropagation();
        this.showDatePicker(dueDateEl, todo);
      });
    }
    if (todo.tags.length > 0) {
      const tagsEl = metaEl.createDiv("todo-tags");
      for (const tag of todo.tags) {
        const tagEl = tagsEl.createSpan("todo-tag");
        tagEl.setText(`#${tag}`);
      }
    }
  }
  renderSortingControlsInternal(container, isModal = false) {
    var _a, _b;
    const sortingEl = container.createDiv("todo-sorting-controls");
    const primarySortContainer = sortingEl.createDiv("sort-container");
    primarySortContainer.createEl("label", { text: "Sort by: ", cls: "sort-label" });
    const primarySortSelect = primarySortContainer.createEl("select", { cls: "sort-select" });
    const sortOptions = [
      { value: "priority", label: "Priority" },
      { value: "dueDate", label: "Due Date" },
      { value: "fileName", label: "File Name" },
      { value: "folderName", label: "Folder" },
      { value: "text", label: "Task Text" },
      { value: "line", label: "Order in File" }
    ];
    sortOptions.forEach((option) => {
      var _a2;
      const optionEl = primarySortSelect.createEl("option", {
        value: option.value,
        text: option.label
      });
      if (option.value === ((_a2 = this.plugin.settings.sortingCriteria[0]) == null ? void 0 : _a2.type)) {
        optionEl.selected = true;
      }
    });
    const directionBtn = primarySortContainer.createEl("button", {
      text: ((_a = this.plugin.settings.sortingCriteria[0]) == null ? void 0 : _a.direction) === "desc" ? "\u2193" : "\u2191",
      cls: "sort-direction-btn"
    });
    directionBtn.title = ((_b = this.plugin.settings.sortingCriteria[0]) == null ? void 0 : _b.direction) === "desc" ? "Descending" : "Ascending";
    primarySortSelect.addEventListener("change", async () => {
      const newType = primarySortSelect.value;
      this.plugin.settings.sortingCriteria[0] = {
        ...this.plugin.settings.sortingCriteria[0],
        type: newType
      };
      await this.plugin.saveSettings();
    });
    directionBtn.addEventListener("click", async () => {
      var _a2;
      const currentDirection = ((_a2 = this.plugin.settings.sortingCriteria[0]) == null ? void 0 : _a2.direction) || "asc";
      const newDirection = currentDirection === "asc" ? "desc" : "asc";
      this.plugin.settings.sortingCriteria[0] = {
        ...this.plugin.settings.sortingCriteria[0],
        direction: newDirection
      };
      directionBtn.textContent = newDirection === "desc" ? "\u2193" : "\u2191";
      directionBtn.title = newDirection === "desc" ? "Descending" : "Ascending";
      await this.plugin.saveSettings();
    });
  }
  renderGroupingControlsInModal(container) {
    this.renderGroupingControlsInternal(container, true);
  }
  renderSortingControlsInModal(container) {
    this.renderSortingControlsInternal(container, true);
  }
  renderGroupingControlsInternal(container, isModal = false) {
    const groupingEl = container.createDiv("todo-grouping-controls");
    const headerEl = groupingEl.createDiv("grouping-header");
    headerEl.createEl("span", { text: "Grouping:", cls: "grouping-header-label" });
    const addButton = headerEl.createEl("button", {
      text: "+ Add",
      cls: "add-grouping-btn"
    });
    addButton.addEventListener("click", async () => {
      const newCriterion = {
        id: `criterion-${Date.now()}`,
        type: "page",
        enabled: true,
        order: this.plugin.settings.groupingCriteria.length
      };
      this.plugin.settings.groupingCriteria.push(newCriterion);
      await this.plugin.saveSettings();
      if (isModal) {
        container.empty();
        this.renderGroupingControlsInternal(container, true);
      } else {
        this.renderPanels();
      }
    });
    const criteriaContainer = groupingEl.createDiv("grouping-criteria-list");
    const enabledCriteria = this.plugin.settings.groupingCriteria.filter((c) => c.enabled).sort((a, b) => a.order - b.order);
    if (enabledCriteria.length === 0) {
      const emptyEl = criteriaContainer.createDiv("grouping-empty");
      emptyEl.setText('No grouping criteria. Click "Add" to create one.');
    } else {
      for (const criterion of enabledCriteria) {
        this.renderGroupingCriterion(criteriaContainer, criterion, container, isModal);
      }
    }
  }
  renderGroupingCriterion(container, criterion, parentContainer, isModal) {
    const criterionEl = container.createDiv("grouping-criterion-panel");
    const typeSelect = criterionEl.createEl("select", { cls: "criterion-type" });
    const typeOptions = [
      { value: "page", label: "Page" },
      { value: "folder", label: "Folder" },
      { value: "tag", label: "Tag" },
      { value: "property", label: "Property" },
      { value: "dueDate", label: "Due Date" },
      { value: "priority", label: "Priority" }
    ];
    typeOptions.forEach((option) => {
      const optionEl = typeSelect.createEl("option", {
        value: option.value,
        text: option.label
      });
      if (option.value === criterion.type) {
        optionEl.selected = true;
      }
    });
    typeSelect.addEventListener("change", async () => {
      criterion.type = typeSelect.value;
      if (criterion.type !== "property") {
        criterion.property = void 0;
      }
      await this.plugin.saveSettings();
      if (isModal) {
        parentContainer.empty();
        this.renderGroupingControlsInternal(parentContainer, true);
      } else {
        this.renderPanels();
      }
    });
    if (criterion.type === "property") {
      const propertySelect = criterionEl.createEl("select", { cls: "criterion-property" });
      propertySelect.createEl("option", { value: "", text: "Select property..." });
      for (const prop of this.plugin.settings.availableProperties) {
        const propOption = propertySelect.createEl("option", {
          value: prop,
          text: prop
        });
        if (prop === criterion.property) {
          propOption.selected = true;
        }
      }
      propertySelect.addEventListener("change", async () => {
        criterion.property = propertySelect.value || void 0;
        await this.plugin.saveSettings();
      });
    }
    const removeBtn = criterionEl.createEl("button", {
      text: "\xD7",
      cls: "remove-grouping-btn"
    });
    removeBtn.addEventListener("click", async () => {
      const index = this.plugin.settings.groupingCriteria.findIndex((c) => c.id === criterion.id);
      if (index !== -1) {
        this.plugin.settings.groupingCriteria.splice(index, 1);
        this.plugin.settings.groupingCriteria.forEach((c, i) => c.order = i);
        await this.plugin.saveSettings();
        if (isModal) {
          parentContainer.empty();
          this.renderGroupingControlsInternal(parentContainer, true);
        } else {
          this.renderPanels();
        }
      }
    });
  }
  toggleSearchPanel() {
    this.panelsState.search = !this.panelsState.search;
    this.panelsState.grouping = false;
    this.panelsState.sorting = false;
    this.renderPanels();
  }
  toggleGroupingPanel() {
    this.panelsState.grouping = !this.panelsState.grouping;
    this.panelsState.search = false;
    this.panelsState.sorting = false;
    this.renderPanels();
  }
  toggleSortingPanel() {
    this.panelsState.sorting = !this.panelsState.sorting;
    this.panelsState.search = false;
    this.panelsState.grouping = false;
    this.renderPanels();
  }
  renderPanels() {
    const panelsContainer = this.viewContentEl.querySelector(".todo-panels-container");
    if (!panelsContainer)
      return;
    panelsContainer.empty();
    if (this.panelsState.search) {
      this.renderSearchPanel(panelsContainer);
    } else if (this.panelsState.grouping) {
      this.renderGroupingPanel(panelsContainer);
    } else if (this.panelsState.sorting) {
      this.renderSortingPanel(panelsContainer);
    }
  }
  renderSearchPanel(container) {
    const panel = container.createDiv("todo-panel search-panel");
    const header = panel.createDiv("todo-panel-header");
    header.createEl("h4", { text: "Search and Filter" });
    const form = panel.createDiv("todo-search-form");
    const formGrid = form.createDiv("search-form-grid");
    const textGroup = formGrid.createDiv("search-group");
    textGroup.createEl("label", { text: "Text:" });
    const textInput = textGroup.createEl("input", {
      type: "text",
      placeholder: "Search tasks...",
      value: this.searchFilters.text
    });
    const pageGroup = formGrid.createDiv("search-group");
    pageGroup.createEl("label", { text: "Page:" });
    const pageInput = pageGroup.createEl("input", {
      type: "text",
      placeholder: "Filter pages...",
      value: this.searchFilters.page
    });
    const priorityGroup = formGrid.createDiv("search-group");
    priorityGroup.createEl("label", { text: "Priority:" });
    const prioritySelect = priorityGroup.createEl("select");
    const priorityOptions = [
      { value: "", label: "Any" },
      { value: "high", label: "High" },
      { value: "medium", label: "Medium" },
      { value: "low", label: "Low" },
      { value: "none", label: "None" }
    ];
    priorityOptions.forEach((option) => {
      const optionEl = prioritySelect.createEl("option", { value: option.value, text: option.label });
      if (option.value === this.searchFilters.priority)
        optionEl.selected = true;
    });
    const fromGroup = formGrid.createDiv("search-group");
    fromGroup.createEl("label", { text: "Due from:" });
    const fromInput = fromGroup.createEl("input", {
      type: "date",
      value: this.searchFilters.dueDateFrom
    });
    const toGroup = formGrid.createDiv("search-group");
    toGroup.createEl("label", { text: "Due to:" });
    const toInput = toGroup.createEl("input", {
      type: "date",
      value: this.searchFilters.dueDateTo
    });
    const checkboxRow = form.createDiv("checkbox-row");
    const linksLabel = checkboxRow.createEl("label", { cls: "checkbox-label" });
    const linksCheckbox = linksLabel.createEl("input", { type: "checkbox" });
    linksLabel.createSpan({ text: "Has links" });
    if (this.searchFilters.hasLinks === true)
      linksCheckbox.checked = true;
    const completedLabel = checkboxRow.createEl("label", { cls: "checkbox-label" });
    const completedCheckbox = completedLabel.createEl("input", { type: "checkbox" });
    completedLabel.createSpan({ text: "Completed only" });
    if (this.searchFilters.completed === true)
      completedCheckbox.checked = true;
    const buttonGroup = form.createDiv("search-buttons");
    const applyBtn = buttonGroup.createEl("button", { text: "Apply", cls: "todo-btn-primary" });
    applyBtn.addEventListener("click", () => {
      this.searchFilters.text = textInput.value;
      this.searchFilters.page = pageInput.value;
      this.searchFilters.priority = prioritySelect.value;
      this.searchFilters.dueDateFrom = fromInput.value;
      this.searchFilters.dueDateTo = toInput.value;
      this.searchFilters.hasLinks = linksCheckbox.checked ? true : null;
      this.searchFilters.completed = completedCheckbox.checked ? true : null;
      this.refreshTodos();
    });
    const clearBtn = buttonGroup.createEl("button", { text: "Clear", cls: "todo-btn-secondary" });
    clearBtn.addEventListener("click", () => {
      this.searchFilters = {
        text: "",
        page: "",
        priority: "",
        dueDateFrom: "",
        dueDateTo: "",
        hasLinks: null,
        completed: null
      };
      this.refreshTodos();
    });
  }
  renderGroupingPanel(container) {
    const panel = container.createDiv("todo-panel grouping-panel");
    const header = panel.createDiv("todo-panel-header");
    header.createEl("h4", { text: "Grouping Settings" });
    this.renderGroupingControlsInternal(panel, false);
  }
  renderSortingPanel(container) {
    const panel = container.createDiv("todo-panel sorting-panel");
    const header = panel.createDiv("todo-panel-header");
    header.createEl("h4", { text: "Sorting Settings" });
    this.renderSortingControlsInternal(panel, false);
  }
  applySearchFilters(groups) {
    return groups.map((group) => {
      const filteredTodos = group.todos.filter((todo) => {
        if (this.searchFilters.text && !todo.displayText.toLowerCase().includes(this.searchFilters.text.toLowerCase())) {
          return false;
        }
        if (this.searchFilters.page && !todo.file.basename.toLowerCase().includes(this.searchFilters.page.toLowerCase())) {
          return false;
        }
        if (this.searchFilters.priority && todo.priority !== this.searchFilters.priority) {
          return false;
        }
        if (this.searchFilters.dueDateFrom || this.searchFilters.dueDateTo) {
          if (!todo.dueDate)
            return false;
          if (this.searchFilters.dueDateFrom) {
            const fromDate = (0, import_obsidian.moment)(this.searchFilters.dueDateFrom);
            if (todo.dueDate.isBefore(fromDate, "day"))
              return false;
          }
          if (this.searchFilters.dueDateTo) {
            const toDate = (0, import_obsidian.moment)(this.searchFilters.dueDateTo);
            if (todo.dueDate.isAfter(toDate, "day"))
              return false;
          }
        }
        if (this.searchFilters.hasLinks === true && todo.linkedNotes.length === 0) {
          return false;
        }
        if (this.searchFilters.completed === true && !todo.completed) {
          return false;
        }
        return true;
      });
      return {
        ...group,
        todos: filteredTodos
      };
    }).filter((group) => group.todos.length > 0);
  }
  showPrioritySelector(priorityEl, todo) {
    const selector = priorityEl.parentElement.createEl("select", { cls: "todo-priority-selector-temp" });
    const priorities = [
      { value: "none", label: "No Priority" },
      { value: "low", label: "Low" },
      { value: "medium", label: "Medium" },
      { value: "high", label: "High" }
    ];
    priorities.forEach((p) => {
      const option = selector.createEl("option", { value: p.value, text: p.label });
      if (p.value === todo.priority)
        option.selected = true;
    });
    priorityEl.style.display = "none";
    selector.focus();
    const handleSelection = async () => {
      const newPriority = selector.value;
      await this.plugin.updateTodoPriority(todo.id, newPriority);
      selector.remove();
      priorityEl.style.display = "";
    };
    const cleanup = () => {
      selector.remove();
      priorityEl.style.display = "";
    };
    selector.addEventListener("change", handleSelection);
    selector.addEventListener("blur", cleanup);
    selector.addEventListener("keydown", (e) => {
      if (e.key === "Escape") {
        cleanup();
      }
    });
  }
  async openTodoFile(todo) {
    const { workspace } = this.app;
    if (this.plugin.settings.openInNewLeaf) {
      const leaf = workspace.getLeaf("tab");
      await leaf.openFile(todo.file);
    } else {
      await workspace.getLeaf().openFile(todo.file);
    }
    setTimeout(() => {
      const activeView = workspace.getActiveViewOfType(import_obsidian.ItemView);
      if (activeView && "editor" in activeView) {
        const editor = activeView.editor;
        if (editor && editor.setCursor) {
          editor.setCursor(todo.line, 0);
          editor.scrollIntoView({ from: { line: todo.line, ch: 0 }, to: { line: todo.line, ch: 0 } }, true);
        }
      }
    }, 100);
  }
  async openLinkedNote(noteName) {
    const { workspace, vault } = this.app;
    const file = vault.getAbstractFileByPath(`${noteName}.md`) || vault.getFiles().find((f) => f.basename === noteName);
    if (file instanceof import_obsidian.TFile) {
      if (this.plugin.settings.openInNewLeaf) {
        const leaf = workspace.getLeaf("tab");
        await leaf.openFile(file);
      } else {
        await workspace.getLeaf().openFile(file);
      }
    } else {
      const newFile = await vault.create(`${noteName}.md`, "");
      if (this.plugin.settings.openInNewLeaf) {
        const leaf = workspace.getLeaf("tab");
        await leaf.openFile(newFile);
      } else {
        await workspace.getLeaf().openFile(newFile);
      }
    }
  }
  showDatePicker(dueDateEl, todo) {
    const existingPicker = document.querySelector(".todo-date-picker");
    if (existingPicker) {
      existingPicker.remove();
    }
    const picker = document.createElement("div");
    picker.className = "todo-date-picker";
    const dateInput = picker.createEl("input", {
      type: "text",
      cls: "date-picker-input",
      placeholder: this.plugin.settings.dateInputFormat
    });
    if (todo.dueDate) {
      dateInput.value = todo.dueDate.format(this.plugin.settings.dateInputFormat);
    }
    const buttonsDiv = picker.createDiv("date-picker-buttons");
    const saveBtn = buttonsDiv.createEl("button", {
      text: "Save",
      cls: "date-picker-save"
    });
    const clearBtn = buttonsDiv.createEl("button", {
      text: "Clear",
      cls: "date-picker-clear"
    });
    const cancelBtn = buttonsDiv.createEl("button", {
      text: "Cancel",
      cls: "date-picker-cancel"
    });
    const rect = dueDateEl.getBoundingClientRect();
    picker.style.position = "absolute";
    picker.style.top = `${rect.bottom + 5}px`;
    picker.style.left = `${rect.left}px`;
    picker.style.zIndex = "1000";
    document.body.appendChild(picker);
    dateInput.focus();
    saveBtn.addEventListener("click", async () => {
      const newDate = dateInput.value ? (0, import_obsidian.moment)(dateInput.value, this.plugin.settings.dateInputFormat, true) : null;
      if (dateInput.value && !(newDate == null ? void 0 : newDate.isValid())) {
        const errorMsg = picker.createDiv("date-picker-error");
        errorMsg.setText(`Invalid date format. Please use ${this.plugin.settings.dateInputFormat}`);
        setTimeout(() => errorMsg.remove(), 3e3);
        return;
      }
      await this.plugin.updateTodoDueDate(todo.id, newDate);
      picker.remove();
    });
    clearBtn.addEventListener("click", async () => {
      await this.plugin.updateTodoDueDate(todo.id, null);
      picker.remove();
    });
    cancelBtn.addEventListener("click", () => {
      picker.remove();
    });
    setTimeout(() => {
      const closeOnOutsideClick = (e) => {
        if (!picker.contains(e.target)) {
          picker.remove();
          document.removeEventListener("click", closeOnOutsideClick);
        }
      };
      document.addEventListener("click", closeOnOutsideClick);
    }, 100);
    const handleEscape = (e) => {
      if (e.key === "Escape") {
        picker.remove();
        document.removeEventListener("keydown", handleEscape);
      }
    };
    document.addEventListener("keydown", handleEscape);
  }
};

// src/Settings.ts
var import_obsidian2 = require("obsidian");
var DEFAULT_SETTINGS = {
  filterMostRecentDaily: false,
  dueDateFormat: "due:%date%",
  dateDisplayFormat: "MMM DD",
  dateInputFormat: "YYYY-MM-DD",
  priorityFormat: "!%priority%",
  groupingCriteria: [
    { id: "primary", type: "page", enabled: true, order: 0 }
  ],
  sortingCriteria: [
    { type: "priority", direction: "asc" },
    { type: "dueDate", direction: "asc" },
    { type: "line", direction: "asc" }
  ],
  hideCompletedTodos: false,
  hideBlankTodos: true,
  openInNewLeaf: false,
  enableInlineEditing: true,
  showImages: true,
  autoCollapseImages: false,
  availableProperties: []
};
var TodoExtendedSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Todo Extended Settings" });
    new import_obsidian2.Setting(containerEl).setName("Filter most recent daily note only").setDesc("When enabled, only shows todos from the most recent daily note to avoid duplicates from rolled-over tasks").addToggle((toggle) => toggle.setValue(this.plugin.settings.filterMostRecentDaily).onChange(async (value) => {
      this.plugin.settings.filterMostRecentDaily = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Due date format").setDesc("Format for due dates in tasks. Use %date% as placeholder for the date").addText((text) => text.setPlaceholder("due:%date%").setValue(this.plugin.settings.dueDateFormat).onChange(async (value) => {
      this.plugin.settings.dueDateFormat = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Date input format").setDesc("Format for entering dates in tasks. Uses moment.js format (e.g., YYYY-MM-DD, DD/MM/YYYY, MM-DD-YYYY)").addText((text) => text.setPlaceholder("YYYY-MM-DD").setValue(this.plugin.settings.dateInputFormat).onChange(async (value) => {
      this.plugin.settings.dateInputFormat = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Date display format").setDesc("How due dates appear in the todo list. Uses moment.js format (e.g., MMM DD, YYYY-MM-DD, DD/MM)").addText((text) => text.setPlaceholder("MMM DD").setValue(this.plugin.settings.dateDisplayFormat).onChange(async (value) => {
      this.plugin.settings.dateDisplayFormat = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Priority format").setDesc("Format for priority indicators. Use %priority% as placeholder (high, medium, low)").addText((text) => text.setPlaceholder("!%priority%").setValue(this.plugin.settings.priorityFormat).onChange(async (value) => {
      this.plugin.settings.priorityFormat = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Advanced Multi-Level Grouping" });
    const groupingDesc = containerEl.createEl("p");
    groupingDesc.setText("Create multiple levels of grouping. Drag to reorder, toggle to enable/disable.");
    this.renderGroupingCriteria(containerEl);
    new import_obsidian2.Setting(containerEl).setName("Hide completed todos").setDesc("When enabled, completed todos will not be shown in the view").addToggle((toggle) => toggle.setValue(this.plugin.settings.hideCompletedTodos).onChange(async (value) => {
      this.plugin.settings.hideCompletedTodos = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Hide blank todos").setDesc("When enabled, todos with no text content will not be shown in the view").addToggle((toggle) => toggle.setValue(this.plugin.settings.hideBlankTodos).onChange(async (value) => {
      this.plugin.settings.hideBlankTodos = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Open files in new leaf").setDesc("When enabled, clicking on a todo will open the file in a new leaf instead of the current one").addToggle((toggle) => toggle.setValue(this.plugin.settings.openInNewLeaf).onChange(async (value) => {
      this.plugin.settings.openInNewLeaf = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Enable inline editing").setDesc("When enabled, allows editing due dates and priority directly from the todo panel").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableInlineEditing).onChange(async (value) => {
      this.plugin.settings.enableInlineEditing = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Image Display" });
    new import_obsidian2.Setting(containerEl).setName("Show images").setDesc("When enabled, images referenced in todos will be displayed in the sidebar").addToggle((toggle) => toggle.setValue(this.plugin.settings.showImages).onChange(async (value) => {
      this.plugin.settings.showImages = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Auto-collapse images").setDesc("When enabled, images will be collapsed by default and can be expanded by clicking").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoCollapseImages).onChange(async (value) => {
      this.plugin.settings.autoCollapseImages = value;
      await this.plugin.saveSettings();
    }));
  }
  renderGroupingCriteria(containerEl) {
    const criteriaContainer = containerEl.createDiv("grouping-criteria-container");
    const addButton = criteriaContainer.createEl("button", {
      text: "Add Grouping Criterion",
      cls: "add-criterion-btn"
    });
    addButton.addEventListener("click", () => {
      const newCriterion = {
        id: `criterion-${Date.now()}`,
        type: "page",
        enabled: true,
        order: this.plugin.settings.groupingCriteria.length
      };
      this.plugin.settings.groupingCriteria.push(newCriterion);
      this.plugin.saveSettings();
      this.display();
    });
    const criteriaList = criteriaContainer.createDiv("criteria-list");
    for (const criterion of this.plugin.settings.groupingCriteria.sort((a, b) => a.order - b.order)) {
      this.renderSingleCriterion(criteriaList, criterion);
    }
  }
  renderSingleCriterion(container, criterion) {
    const criterionEl = container.createDiv("grouping-criterion");
    const dragHandle = criterionEl.createEl("span", {
      text: "\u22EE\u22EE",
      cls: "drag-handle"
    });
    const toggleEl = criterionEl.createEl("input", {
      type: "checkbox",
      cls: "criterion-toggle"
    });
    toggleEl.checked = criterion.enabled;
    toggleEl.addEventListener("change", async () => {
      criterion.enabled = toggleEl.checked;
      await this.plugin.saveSettings();
    });
    const typeSelect = criterionEl.createEl("select", { cls: "criterion-type" });
    const typeOptions = [
      { value: "page", label: "Page" },
      { value: "folder", label: "Folder" },
      { value: "tag", label: "Tag" },
      { value: "property", label: "Property" },
      { value: "dueDate", label: "Due Date" },
      { value: "priority", label: "Priority" }
    ];
    typeOptions.forEach((option) => {
      const optionEl = typeSelect.createEl("option", {
        value: option.value,
        text: option.label
      });
      if (option.value === criterion.type) {
        optionEl.selected = true;
      }
    });
    typeSelect.addEventListener("change", async () => {
      criterion.type = typeSelect.value;
      if (criterion.type !== "property") {
        criterion.property = void 0;
      }
      await this.plugin.saveSettings();
      this.display();
    });
    if (criterion.type === "property") {
      const propertySelect = criterionEl.createEl("select", { cls: "criterion-property" });
      propertySelect.createEl("option", { value: "", text: "Select property..." });
      for (const prop of this.plugin.settings.availableProperties) {
        const propOption = propertySelect.createEl("option", {
          value: prop,
          text: prop
        });
        if (prop === criterion.property) {
          propOption.selected = true;
        }
      }
      propertySelect.addEventListener("change", async () => {
        criterion.property = propertySelect.value || void 0;
        await this.plugin.saveSettings();
      });
    }
    const removeBtn = criterionEl.createEl("button", {
      text: "\xD7",
      cls: "remove-criterion-btn"
    });
    removeBtn.addEventListener("click", async () => {
      const index = this.plugin.settings.groupingCriteria.findIndex((c) => c.id === criterion.id);
      if (index !== -1) {
        this.plugin.settings.groupingCriteria.splice(index, 1);
        this.plugin.settings.groupingCriteria.forEach((c, i) => c.order = i);
        await this.plugin.saveSettings();
        this.display();
      }
    });
    criterionEl.draggable = true;
    criterionEl.addEventListener("dragstart", (e) => {
      if (e.dataTransfer) {
        e.dataTransfer.setData("text/plain", criterion.id);
      }
    });
    criterionEl.addEventListener("dragover", (e) => {
      e.preventDefault();
    });
    criterionEl.addEventListener("drop", async (e) => {
      e.preventDefault();
      if (e.dataTransfer) {
        const draggedId = e.dataTransfer.getData("text/plain");
        const draggedIndex = this.plugin.settings.groupingCriteria.findIndex((c) => c.id === draggedId);
        const targetIndex = this.plugin.settings.groupingCriteria.findIndex((c) => c.id === criterion.id);
        if (draggedIndex !== -1 && targetIndex !== -1 && draggedIndex !== targetIndex) {
          const draggedCriterion = this.plugin.settings.groupingCriteria[draggedIndex];
          this.plugin.settings.groupingCriteria.splice(draggedIndex, 1);
          this.plugin.settings.groupingCriteria.splice(targetIndex, 0, draggedCriterion);
          this.plugin.settings.groupingCriteria.forEach((c, i) => c.order = i);
          await this.plugin.saveSettings();
          this.display();
        }
      }
    });
  }
};

// main.ts
var TodoExtendedPlugin = class extends import_obsidian3.Plugin {
  async onload() {
    await this.loadSettings();
    await this.scanAvailableProperties();
    this.registerView(
      VIEW_TYPE_TODO_EXTENDED,
      (leaf) => new TodoExtendedView(leaf, this)
    );
    this.addRibbonIcon("checkmark", "Todo Extended", () => {
      this.activateView();
    });
    this.addCommand({
      id: "open-todo-extended",
      name: "Open Todo Extended View",
      callback: () => {
        this.activateView();
      }
    });
    this.addSettingTab(new TodoExtendedSettingTab(this.app, this));
    this.registerEvent(
      this.app.vault.on("modify", (file) => {
        if (file instanceof import_obsidian3.TFile) {
          this.refreshTodos();
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("create", (file) => {
        if (file instanceof import_obsidian3.TFile) {
          this.refreshTodos();
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("delete", (file) => {
        this.refreshTodos();
      })
    );
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    await this.scanAvailableProperties();
    this.refreshTodos();
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_TODO_EXTENDED);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      if (leaf) {
        await leaf.setViewState({ type: VIEW_TYPE_TODO_EXTENDED, active: true });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
  refreshTodos() {
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_TODO_EXTENDED);
    leaves.forEach((leaf) => {
      if (leaf.view instanceof TodoExtendedView) {
        leaf.view.refreshTodos();
      }
    });
  }
  async getAllTodos() {
    const files = this.app.vault.getMarkdownFiles();
    const nestedGroups = /* @__PURE__ */ new Map();
    for (const file of files) {
      if (this.settings.filterMostRecentDaily && this.isDailyNote(file)) {
        if (!this.isMostRecentDailyNote(file)) {
          continue;
        }
      }
      const content = await this.app.vault.read(file);
      const cache = this.app.metadataCache.getFileCache(file);
      const todos = this.extractTodosFromFile(file, content, cache);
      for (const todo of todos) {
        const groupKeys = this.getMultiLevelGroupKey(todo, file);
        const groupKey = groupKeys.join(" > ");
        if (!nestedGroups.has(groupKey)) {
          nestedGroups.set(groupKey, []);
        }
        nestedGroups.get(groupKey).push(todo);
      }
    }
    const groups = [];
    for (const [groupName, todos] of nestedGroups) {
      const sortedTodos = this.sortTodosWithHierarchy(todos);
      groups.push({
        name: groupName,
        todos: sortedTodos
      });
    }
    return groups.sort((a, b) => {
      const isNoValueGroup = (name) => {
        const lowerName = name.toLowerCase();
        return lowerName.includes("no ") || lowerName.includes("none") || lowerName === "root" || lowerName.includes("all todos");
      };
      const aIsNoValue = isNoValueGroup(a.name);
      const bIsNoValue = isNoValueGroup(b.name);
      if (aIsNoValue && !bIsNoValue)
        return 1;
      if (!aIsNoValue && bIsNoValue)
        return -1;
      return a.name.localeCompare(b.name);
    });
  }
  sortTodosWithHierarchy(todos) {
    return todos.sort((a, b) => {
      for (const criterion of this.settings.sortingCriteria) {
        const result = this.compareTodos(a, b, criterion);
        if (result !== 0)
          return result;
      }
      return 0;
    });
  }
  compareTodos(a, b, criterion) {
    var _a, _b;
    let result = 0;
    switch (criterion.type) {
      case "priority":
        const priorityOrder = { "high": 0, "medium": 1, "low": 2, "none": 3 };
        result = priorityOrder[a.priority] - priorityOrder[b.priority];
        break;
      case "dueDate":
        if (a.dueDate && b.dueDate) {
          result = a.dueDate.diff(b.dueDate);
        } else if (a.dueDate && !b.dueDate) {
          result = -1;
        } else if (!a.dueDate && b.dueDate) {
          result = 1;
        }
        break;
      case "fileName":
        result = a.file.basename.localeCompare(b.file.basename);
        break;
      case "folderName":
        const aFolder = ((_a = a.file.parent) == null ? void 0 : _a.path) || "";
        const bFolder = ((_b = b.file.parent) == null ? void 0 : _b.path) || "";
        result = aFolder.localeCompare(bFolder);
        break;
      case "text":
        result = a.displayText.localeCompare(b.displayText);
        break;
      case "createdDate":
        result = a.file.stat.ctime - b.file.stat.ctime;
        break;
      case "line":
        const fileCompare = a.file.path.localeCompare(b.file.path);
        if (fileCompare !== 0) {
          result = fileCompare;
        } else {
          result = a.line - b.line;
        }
        break;
    }
    return criterion.direction === "desc" ? -result : result;
  }
  extractTodosFromFile(file, content, cache) {
    const todos = [];
    const lines = content.split("\n");
    const parentStack = [];
    lines.forEach((line, index) => {
      const todoMatch = line.match(/^(\s*)(- \[[ x]\])\s*(.*)$/);
      if (todoMatch) {
        const [, indent, checkbox, text] = todoMatch;
        const isCompleted = checkbox.includes("x");
        const indentLevel = indent.length;
        if (isCompleted && this.settings.hideCompletedTodos) {
          return;
        }
        if (text.trim() === "" && this.settings.hideBlankTodos) {
          return;
        }
        const explicitPriority = this.extractPriority(text);
        while (parentStack.length > 0 && parentStack[parentStack.length - 1].indent >= indentLevel) {
          parentStack.pop();
        }
        let effectivePriority = explicitPriority;
        if (explicitPriority === "none" && parentStack.length > 0) {
          for (let i = parentStack.length - 1; i >= 0; i--) {
            if (parentStack[i].priority !== "none") {
              effectivePriority = parentStack[i].priority;
              break;
            }
          }
        }
        const todo = {
          id: `${file.path}:${index}`,
          text: text.trim(),
          completed: isCompleted,
          file,
          line: index,
          indent: indentLevel,
          dueDate: this.extractDueDate(text),
          priority: effectivePriority,
          tags: this.extractTags(text),
          properties: this.extractProperties(cache),
          originalText: line,
          linkedNotes: this.extractLinkedNotes(text),
          displayText: this.createDisplayText(text),
          images: this.extractImages(text)
        };
        parentStack.push({ indent: indentLevel, priority: effectivePriority });
        todos.push(todo);
      }
    });
    return todos;
  }
  extractDueDate(text) {
    const dateFormat = this.settings.dateInputFormat;
    const dueDatePattern = this.settings.dueDateFormat.replace("%date%", `([^\\s]+)`);
    let match = text.match(new RegExp(dueDatePattern));
    if (match) {
      const dateStr = match[1];
      const parsedDate = (0, import_obsidian3.moment)(dateStr, dateFormat, true);
      if (parsedDate.isValid()) {
        return parsedDate;
      }
    }
    match = text.match(/!due:([^\s]+)/i);
    if (match) {
      const dateStr = match[1];
      const parsedDate = (0, import_obsidian3.moment)(dateStr, dateFormat, true);
      if (parsedDate.isValid()) {
        return parsedDate;
      }
    }
    match = text.match(/due:([^\s]+)/i);
    if (match) {
      const dateStr = match[1];
      const parsedDate = (0, import_obsidian3.moment)(dateStr, dateFormat, true);
      if (parsedDate.isValid()) {
        return parsedDate;
      }
    }
    return null;
  }
  extractPriority(text) {
    const priorityPattern = this.settings.priorityFormat.replace("%priority%", "(high|medium|low)");
    const match = text.match(new RegExp(priorityPattern, "i"));
    if (match) {
      return match[1].toLowerCase();
    }
    return "none";
  }
  extractTags(text) {
    const tagMatches = text.match(/#[\w-]+/g);
    return tagMatches ? tagMatches.map((tag) => tag.substring(1)) : [];
  }
  extractProperties(cache) {
    return (cache == null ? void 0 : cache.frontmatter) || {};
  }
  extractLinkedNotes(text) {
    const linkMatches = text.match(/\[\[([^\]]+)\]\]/g);
    if (!linkMatches)
      return [];
    return linkMatches.map((link) => {
      const noteName = link.slice(2, -2);
      return noteName.split("|")[0];
    });
  }
  createDisplayText(text) {
    let displayText = text.replace(/\[\[([^\]]+)\]\]/g, (match, noteName) => {
      const parts = noteName.split("|");
      return parts.length > 1 ? parts[1] : parts[0];
    });
    displayText = displayText.replace(/!\[[^\]]*\]\([^)]+\)/g, "");
    displayText = displayText.replace(/!\[\[([^\]]+)\]\]/g, "");
    const dueDatePattern = this.settings.dueDateFormat.replace("%date%", "[^\\s]+");
    displayText = displayText.replace(new RegExp("\\s*" + dueDatePattern, "g"), "");
    const priorityPattern = this.settings.priorityFormat.replace("%priority%", "(high|medium|low)");
    displayText = displayText.replace(new RegExp("\\s*" + priorityPattern, "gi"), "");
    displayText = displayText.replace(/\s*!due:[^\s]+/gi, "");
    displayText = displayText.replace(/\s*due:[^\s]+/gi, "");
    displayText = displayText.replace(/\s*!\s*$/, "");
    return displayText.trim();
  }
  extractImages(text) {
    const images = [];
    const markdownImageMatches = text.match(/!\[[^\]]*\]\(([^)]+)\)/g);
    if (markdownImageMatches) {
      markdownImageMatches.forEach((match) => {
        const pathMatch = match.match(/!\[[^\]]*\]\(([^)]+)\)/);
        if (pathMatch) {
          const imagePath = pathMatch[1];
          images.push(imagePath);
        }
      });
    }
    const wikiImageMatches = text.match(/!\[\[([^\]]+)\]\]/g);
    if (wikiImageMatches) {
      wikiImageMatches.forEach((match) => {
        const pathMatch = match.match(/!\[\[([^\]]+)\]\]/);
        if (pathMatch) {
          const imageName = pathMatch[1];
          const imageFile = this.app.vault.getFiles().find(
            (f) => f.name === imageName || f.basename === imageName
          );
          if (imageFile) {
            const resourcePath = this.app.vault.getResourcePath(imageFile);
            images.push(resourcePath);
          }
        }
      });
    }
    return images;
  }
  isDailyNote(file) {
    const datePattern = /^\d{4}-\d{2}-\d{2}$/;
    return datePattern.test(file.basename);
  }
  isMostRecentDailyNote(file) {
    const files = this.app.vault.getMarkdownFiles();
    const dailyNotes = files.filter((f) => this.isDailyNote(f));
    if (dailyNotes.length === 0)
      return false;
    dailyNotes.sort((a, b) => b.basename.localeCompare(a.basename));
    return dailyNotes[0].path === file.path;
  }
  async toggleTodo(todoId) {
    const [filePath, lineStr] = todoId.split(":");
    const line = parseInt(lineStr);
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (!(file instanceof import_obsidian3.TFile))
      return;
    const content = await this.app.vault.read(file);
    const lines = content.split("\n");
    if (line < lines.length) {
      const currentLine = lines[line];
      const newLine = currentLine.replace(/- \[[ x]\]/, (match) => {
        return match.includes("x") ? "- [ ]" : "- [x]";
      });
      lines[line] = newLine;
      await this.app.vault.modify(file, lines.join("\n"));
    }
  }
  async updateTodoDueDate(todoId, dueDate) {
    const [filePath, lineStr] = todoId.split(":");
    const line = parseInt(lineStr);
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (!(file instanceof import_obsidian3.TFile))
      return;
    const content = await this.app.vault.read(file);
    const lines = content.split("\n");
    if (line < lines.length) {
      let currentLine = lines[line];
      const dueDatePattern = this.settings.dueDateFormat.replace("%date%", "[^\\s]+");
      currentLine = currentLine.replace(new RegExp("\\s*" + dueDatePattern), "");
      if (dueDate) {
        const dueDateStr = this.settings.dueDateFormat.replace("%date%", dueDate.format(this.settings.dateInputFormat));
        currentLine = currentLine.trim() + " " + dueDateStr;
      }
      lines[line] = currentLine;
      await this.app.vault.modify(file, lines.join("\n"));
    }
  }
  async updateTodoPriority(todoId, priority) {
    const [filePath, lineStr] = todoId.split(":");
    const line = parseInt(lineStr);
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (!(file instanceof import_obsidian3.TFile))
      return;
    const content = await this.app.vault.read(file);
    const lines = content.split("\n");
    if (line < lines.length) {
      let currentLine = lines[line];
      const priorityPattern = this.settings.priorityFormat.replace("%priority%", "(high|medium|low)");
      currentLine = currentLine.replace(new RegExp("\\s*" + priorityPattern, "i"), "");
      if (priority !== "none") {
        const priorityStr = this.settings.priorityFormat.replace("%priority%", priority);
        currentLine = currentLine.trim() + " " + priorityStr;
      }
      lines[line] = currentLine;
      await this.app.vault.modify(file, lines.join("\n"));
    }
  }
  async scanAvailableProperties() {
    const files = this.app.vault.getMarkdownFiles();
    const properties = /* @__PURE__ */ new Set();
    for (const file of files) {
      const cache = this.app.metadataCache.getFileCache(file);
      if (cache == null ? void 0 : cache.frontmatter) {
        Object.keys(cache.frontmatter).forEach((key) => {
          if (key !== "position" && !key.startsWith("_")) {
            properties.add(key);
          }
        });
      }
    }
    this.settings.availableProperties = Array.from(properties).sort();
  }
  getMultiLevelGroupKey(todo, file) {
    var _a;
    const keys = [];
    for (const criterion of this.settings.groupingCriteria.filter((c) => c.enabled).sort((a, b) => a.order - b.order)) {
      let key = "";
      switch (criterion.type) {
        case "page":
          key = file.basename;
          break;
        case "folder":
          key = ((_a = file.parent) == null ? void 0 : _a.name) || "Root";
          break;
        case "tag":
          key = todo.tags.length > 0 ? `#${todo.tags[0]}` : "No Tag";
          break;
        case "property":
          if (criterion.property) {
            const propValue = todo.properties[criterion.property];
            key = propValue ? String(propValue) : `No ${criterion.property}`;
          } else {
            key = "No Property";
          }
          break;
        case "dueDate":
          key = todo.dueDate ? todo.dueDate.format("YYYY-MM-DD") : "No Due Date";
          break;
        case "priority":
          key = todo.priority === "none" ? "No Priority" : `${todo.priority.charAt(0).toUpperCase() + todo.priority.slice(1)} Priority`;
          break;
        default:
          key = "All Todos";
      }
      keys.push(key);
    }
    return keys.length > 0 ? keys : ["All Todos"];
  }
};
