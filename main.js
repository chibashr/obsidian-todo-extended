/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TodoExtendedPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/TodoExtendedView.ts
var import_obsidian = require("obsidian");
var VIEW_TYPE_TODO_EXTENDED = "todo-extended-view";
var TodoExtendedView = class extends import_obsidian.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_TYPE_TODO_EXTENDED;
  }
  getDisplayText() {
    return "Todo Extended";
  }
  getIcon() {
    return "checkmark";
  }
  async onOpen() {
    this.viewContentEl = this.containerEl.children[1];
    this.viewContentEl.empty();
    this.viewContentEl.addClass("todo-extended-view");
    await this.refreshTodos();
  }
  async onClose() {
  }
  async refreshTodos() {
    if (!this.viewContentEl)
      return;
    this.viewContentEl.empty();
    const headerEl = this.viewContentEl.createDiv("todo-extended-header");
    headerEl.createEl("h3", { text: "Todo Extended" });
    const refreshBtn = headerEl.createEl("button", {
      text: "\u21BB",
      cls: "todo-refresh-btn"
    });
    refreshBtn.addEventListener("click", () => this.refreshTodos());
    const loadingEl = this.viewContentEl.createDiv("todo-loading");
    loadingEl.setText("Loading todos...");
    try {
      const groups = await this.plugin.getAllTodos();
      loadingEl.remove();
      if (groups.length === 0) {
        const emptyEl = this.viewContentEl.createDiv("todo-empty");
        emptyEl.setText("No todos found");
        return;
      }
      const todosEl = this.viewContentEl.createDiv("todos-container");
      for (const group of groups) {
        this.renderGroup(todosEl, group);
      }
    } catch (error) {
      loadingEl.setText("Error loading todos");
      console.error("TodoExtended: Error loading todos", error);
    }
  }
  renderGroup(container, group) {
    const groupEl = container.createDiv("todo-group");
    if (this.plugin.settings.groupingCriteria.some((c) => c.enabled)) {
      const headerEl = groupEl.createDiv("todo-group-header");
      headerEl.createEl("h4", { text: group.name });
      headerEl.createEl("span", {
        text: `(${group.todos.length})`,
        cls: "todo-count"
      });
    }
    const listEl = groupEl.createDiv("todo-list");
    for (const todo of group.todos) {
      this.renderTodo(listEl, todo);
    }
  }
  renderTodo(container, todo) {
    const todoEl = container.createDiv("todo-item");
    if (todo.completed) {
      todoEl.addClass("todo-completed");
    }
    if (todo.indent > 0) {
      todoEl.addClass("todo-child");
      if (todo.indent >= 4) {
        todoEl.addClass("todo-child-level-2");
      }
      if (todo.indent >= 8) {
        todoEl.addClass("todo-child-level-3");
      }
    }
    const checkboxEl = todoEl.createEl("input", {
      type: "checkbox",
      cls: "todo-checkbox"
    });
    checkboxEl.checked = todo.completed;
    checkboxEl.addEventListener("change", async () => {
      await this.plugin.toggleTodo(todo.id);
    });
    const contentEl = todoEl.createDiv("todo-content");
    const textEl = contentEl.createDiv("todo-text");
    textEl.setText(todo.displayText);
    textEl.addEventListener("click", () => this.openTodoFile(todo));
    if (todo.linkedNotes.length > 0) {
      const linkedNotesEl = todoEl.createDiv("todo-linked-notes");
      for (const noteName of todo.linkedNotes) {
        const linkBtn = linkedNotesEl.createEl("button", {
          cls: "todo-link-icon"
        });
        linkBtn.innerHTML = "\u{1F517}";
        linkBtn.title = `Open ${noteName}`;
        linkBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          this.openLinkedNote(noteName);
        });
      }
    }
    if (this.plugin.settings.showImages && todo.images.length > 0) {
      const imagesEl = contentEl.createDiv("todo-images");
      if (this.plugin.settings.autoCollapseImages) {
        imagesEl.addClass("todo-images-collapsed");
        const toggleBtn = imagesEl.createEl("button", {
          text: `\u{1F4F7} ${todo.images.length} image${todo.images.length > 1 ? "s" : ""}`,
          cls: "todo-images-toggle"
        });
        const imageContainer = imagesEl.createDiv("todo-images-container");
        toggleBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          imageContainer.toggleClass("todo-images-expanded", !imageContainer.hasClass("todo-images-expanded"));
          toggleBtn.setText(imageContainer.hasClass("todo-images-expanded") ? "\u{1F4F7} Hide images" : `\u{1F4F7} ${todo.images.length} image${todo.images.length > 1 ? "s" : ""}`);
        });
        for (const imagePath of todo.images) {
          const imgEl = imageContainer.createEl("img", {
            cls: "todo-image"
          });
          imgEl.src = imagePath;
        }
      } else {
        for (const imagePath of todo.images) {
          const imgEl = imagesEl.createEl("img", {
            cls: "todo-image"
          });
          imgEl.src = imagePath;
        }
      }
    }
    const metaEl = contentEl.createDiv("todo-meta");
    const fileEl = metaEl.createSpan("todo-file");
    fileEl.setText(todo.file.basename);
    fileEl.addEventListener("click", () => this.openTodoFile(todo));
    if (todo.priority !== "none") {
      const priorityEl = metaEl.createSpan("todo-priority");
      priorityEl.addClass(`todo-priority-${todo.priority}`);
      priorityEl.setText(`${todo.priority.toUpperCase()}`);
    }
    if (this.plugin.settings.enableInlineEditing) {
      const prioritySelector = metaEl.createEl("select", { cls: "todo-priority-selector" });
      const priorities = [
        { value: "none", label: "No Priority" },
        { value: "low", label: "Low" },
        { value: "medium", label: "Medium" },
        { value: "high", label: "High" }
      ];
      priorities.forEach((p) => {
        const option = prioritySelector.createEl("option", { value: p.value, text: p.label });
        if (p.value === todo.priority)
          option.selected = true;
      });
      prioritySelector.addEventListener("change", async () => {
        const newPriority = prioritySelector.value;
        await this.plugin.updateTodoPriority(todo.id, newPriority);
      });
    }
    const dueDateEl = metaEl.createSpan("todo-due-date clickable-date");
    if (todo.dueDate) {
      const isOverdue = todo.dueDate.isBefore(window.moment(), "day");
      const isToday = todo.dueDate.isSame(window.moment(), "day");
      if (isOverdue) {
        dueDateEl.addClass("todo-overdue");
      } else if (isToday) {
        dueDateEl.addClass("todo-today");
      }
      dueDateEl.setText(todo.dueDate.format(this.plugin.settings.dateDisplayFormat));
    } else {
      dueDateEl.setText("Set due date");
      dueDateEl.addClass("todo-no-date");
    }
    if (this.plugin.settings.enableInlineEditing) {
      dueDateEl.addEventListener("click", (e) => {
        e.stopPropagation();
        this.showDatePicker(dueDateEl, todo);
      });
    }
    if (todo.tags.length > 0) {
      const tagsEl = metaEl.createDiv("todo-tags");
      for (const tag of todo.tags) {
        const tagEl = tagsEl.createSpan("todo-tag");
        tagEl.setText(`#${tag}`);
      }
    }
  }
  async openTodoFile(todo) {
    const { workspace } = this.app;
    if (this.plugin.settings.openInNewLeaf) {
      const leaf = workspace.getLeaf("tab");
      await leaf.openFile(todo.file);
    } else {
      await workspace.getLeaf().openFile(todo.file);
    }
    setTimeout(() => {
      const activeView = workspace.getActiveViewOfType(import_obsidian.ItemView);
      if (activeView && "editor" in activeView) {
        const editor = activeView.editor;
        if (editor && editor.setCursor) {
          editor.setCursor(todo.line, 0);
          editor.scrollIntoView({ from: { line: todo.line, ch: 0 }, to: { line: todo.line, ch: 0 } }, true);
        }
      }
    }, 100);
  }
  async openLinkedNote(noteName) {
    const { workspace, vault } = this.app;
    const file = vault.getAbstractFileByPath(`${noteName}.md`) || vault.getFiles().find((f) => f.basename === noteName);
    if (file instanceof import_obsidian.TFile) {
      if (this.plugin.settings.openInNewLeaf) {
        const leaf = workspace.getLeaf("tab");
        await leaf.openFile(file);
      } else {
        await workspace.getLeaf().openFile(file);
      }
    } else {
      const newFile = await vault.create(`${noteName}.md`, "");
      if (this.plugin.settings.openInNewLeaf) {
        const leaf = workspace.getLeaf("tab");
        await leaf.openFile(newFile);
      } else {
        await workspace.getLeaf().openFile(newFile);
      }
    }
  }
  showDatePicker(dueDateEl, todo) {
    const existingPicker = document.querySelector(".todo-date-picker");
    if (existingPicker) {
      existingPicker.remove();
    }
    const picker = document.createElement("div");
    picker.className = "todo-date-picker";
    const dateInput = picker.createEl("input", {
      type: "text",
      cls: "date-picker-input",
      placeholder: this.plugin.settings.dateInputFormat
    });
    if (todo.dueDate) {
      dateInput.value = todo.dueDate.format(this.plugin.settings.dateInputFormat);
    }
    const buttonsDiv = picker.createDiv("date-picker-buttons");
    const saveBtn = buttonsDiv.createEl("button", {
      text: "Save",
      cls: "date-picker-save"
    });
    const clearBtn = buttonsDiv.createEl("button", {
      text: "Clear",
      cls: "date-picker-clear"
    });
    const cancelBtn = buttonsDiv.createEl("button", {
      text: "Cancel",
      cls: "date-picker-cancel"
    });
    const rect = dueDateEl.getBoundingClientRect();
    picker.style.position = "absolute";
    picker.style.top = `${rect.bottom + 5}px`;
    picker.style.left = `${rect.left}px`;
    picker.style.zIndex = "1000";
    document.body.appendChild(picker);
    dateInput.focus();
    saveBtn.addEventListener("click", async () => {
      const newDate = dateInput.value ? (0, import_obsidian.moment)(dateInput.value, this.plugin.settings.dateInputFormat, true) : null;
      if (dateInput.value && !(newDate == null ? void 0 : newDate.isValid())) {
        const errorMsg = picker.createDiv("date-picker-error");
        errorMsg.setText(`Invalid date format. Please use ${this.plugin.settings.dateInputFormat}`);
        setTimeout(() => errorMsg.remove(), 3e3);
        return;
      }
      await this.plugin.updateTodoDueDate(todo.id, newDate);
      picker.remove();
    });
    clearBtn.addEventListener("click", async () => {
      await this.plugin.updateTodoDueDate(todo.id, null);
      picker.remove();
    });
    cancelBtn.addEventListener("click", () => {
      picker.remove();
    });
    setTimeout(() => {
      const closeOnOutsideClick = (e) => {
        if (!picker.contains(e.target)) {
          picker.remove();
          document.removeEventListener("click", closeOnOutsideClick);
        }
      };
      document.addEventListener("click", closeOnOutsideClick);
    }, 100);
    const handleEscape = (e) => {
      if (e.key === "Escape") {
        picker.remove();
        document.removeEventListener("keydown", handleEscape);
      }
    };
    document.addEventListener("keydown", handleEscape);
  }
};

// src/Settings.ts
var import_obsidian2 = require("obsidian");
var DEFAULT_SETTINGS = {
  filterMostRecentDaily: false,
  dueDateFormat: "due:%date%",
  dateDisplayFormat: "MMM DD",
  dateInputFormat: "YYYY-MM-DD",
  priorityFormat: "!%priority%",
  groupingCriteria: [
    { id: "primary", type: "page", enabled: true, order: 0 }
  ],
  hideCompletedTodos: false,
  hideBlankTodos: true,
  openInNewLeaf: false,
  enableInlineEditing: true,
  showImages: true,
  autoCollapseImages: false,
  availableProperties: []
};
var TodoExtendedSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Todo Extended Settings" });
    new import_obsidian2.Setting(containerEl).setName("Filter most recent daily note only").setDesc("When enabled, only shows todos from the most recent daily note to avoid duplicates from rolled-over tasks").addToggle((toggle) => toggle.setValue(this.plugin.settings.filterMostRecentDaily).onChange(async (value) => {
      this.plugin.settings.filterMostRecentDaily = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Due date format").setDesc("Format for due dates in tasks. Use %date% as placeholder for the date").addText((text) => text.setPlaceholder("due:%date%").setValue(this.plugin.settings.dueDateFormat).onChange(async (value) => {
      this.plugin.settings.dueDateFormat = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Date input format").setDesc("Format for entering dates in tasks. Uses moment.js format (e.g., YYYY-MM-DD, DD/MM/YYYY, MM-DD-YYYY)").addText((text) => text.setPlaceholder("YYYY-MM-DD").setValue(this.plugin.settings.dateInputFormat).onChange(async (value) => {
      this.plugin.settings.dateInputFormat = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Date display format").setDesc("How due dates appear in the todo list. Uses moment.js format (e.g., MMM DD, YYYY-MM-DD, DD/MM)").addText((text) => text.setPlaceholder("MMM DD").setValue(this.plugin.settings.dateDisplayFormat).onChange(async (value) => {
      this.plugin.settings.dateDisplayFormat = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Priority format").setDesc("Format for priority indicators. Use %priority% as placeholder (high, medium, low)").addText((text) => text.setPlaceholder("!%priority%").setValue(this.plugin.settings.priorityFormat).onChange(async (value) => {
      this.plugin.settings.priorityFormat = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Advanced Multi-Level Grouping" });
    const groupingDesc = containerEl.createEl("p");
    groupingDesc.setText("Create multiple levels of grouping. Drag to reorder, toggle to enable/disable.");
    this.renderGroupingCriteria(containerEl);
    new import_obsidian2.Setting(containerEl).setName("Hide completed todos").setDesc("When enabled, completed todos will not be shown in the view").addToggle((toggle) => toggle.setValue(this.plugin.settings.hideCompletedTodos).onChange(async (value) => {
      this.plugin.settings.hideCompletedTodos = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Hide blank todos").setDesc("When enabled, todos with no text content will not be shown in the view").addToggle((toggle) => toggle.setValue(this.plugin.settings.hideBlankTodos).onChange(async (value) => {
      this.plugin.settings.hideBlankTodos = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Open files in new leaf").setDesc("When enabled, clicking on a todo will open the file in a new leaf instead of the current one").addToggle((toggle) => toggle.setValue(this.plugin.settings.openInNewLeaf).onChange(async (value) => {
      this.plugin.settings.openInNewLeaf = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Enable inline editing").setDesc("When enabled, allows editing due dates and priority directly from the todo panel").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableInlineEditing).onChange(async (value) => {
      this.plugin.settings.enableInlineEditing = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Image Display" });
    new import_obsidian2.Setting(containerEl).setName("Show images").setDesc("When enabled, images referenced in todos will be displayed in the sidebar").addToggle((toggle) => toggle.setValue(this.plugin.settings.showImages).onChange(async (value) => {
      this.plugin.settings.showImages = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Auto-collapse images").setDesc("When enabled, images will be collapsed by default and can be expanded by clicking").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoCollapseImages).onChange(async (value) => {
      this.plugin.settings.autoCollapseImages = value;
      await this.plugin.saveSettings();
    }));
  }
  renderGroupingCriteria(containerEl) {
    const criteriaContainer = containerEl.createDiv("grouping-criteria-container");
    const addButton = criteriaContainer.createEl("button", {
      text: "Add Grouping Criterion",
      cls: "add-criterion-btn"
    });
    addButton.addEventListener("click", () => {
      const newCriterion = {
        id: `criterion-${Date.now()}`,
        type: "page",
        enabled: true,
        order: this.plugin.settings.groupingCriteria.length
      };
      this.plugin.settings.groupingCriteria.push(newCriterion);
      this.plugin.saveSettings();
      this.display();
    });
    const criteriaList = criteriaContainer.createDiv("criteria-list");
    for (const criterion of this.plugin.settings.groupingCriteria.sort((a, b) => a.order - b.order)) {
      this.renderSingleCriterion(criteriaList, criterion);
    }
  }
  renderSingleCriterion(container, criterion) {
    const criterionEl = container.createDiv("grouping-criterion");
    const dragHandle = criterionEl.createEl("span", {
      text: "\u22EE\u22EE",
      cls: "drag-handle"
    });
    const toggleEl = criterionEl.createEl("input", {
      type: "checkbox",
      cls: "criterion-toggle"
    });
    toggleEl.checked = criterion.enabled;
    toggleEl.addEventListener("change", async () => {
      criterion.enabled = toggleEl.checked;
      await this.plugin.saveSettings();
    });
    const typeSelect = criterionEl.createEl("select", { cls: "criterion-type" });
    const typeOptions = [
      { value: "page", label: "Page" },
      { value: "folder", label: "Folder" },
      { value: "tag", label: "Tag" },
      { value: "property", label: "Property" },
      { value: "dueDate", label: "Due Date" },
      { value: "priority", label: "Priority" }
    ];
    typeOptions.forEach((option) => {
      const optionEl = typeSelect.createEl("option", {
        value: option.value,
        text: option.label
      });
      if (option.value === criterion.type) {
        optionEl.selected = true;
      }
    });
    typeSelect.addEventListener("change", async () => {
      criterion.type = typeSelect.value;
      if (criterion.type !== "property") {
        criterion.property = void 0;
      }
      await this.plugin.saveSettings();
      this.display();
    });
    if (criterion.type === "property") {
      const propertySelect = criterionEl.createEl("select", { cls: "criterion-property" });
      propertySelect.createEl("option", { value: "", text: "Select property..." });
      for (const prop of this.plugin.settings.availableProperties) {
        const propOption = propertySelect.createEl("option", {
          value: prop,
          text: prop
        });
        if (prop === criterion.property) {
          propOption.selected = true;
        }
      }
      propertySelect.addEventListener("change", async () => {
        criterion.property = propertySelect.value || void 0;
        await this.plugin.saveSettings();
      });
    }
    const removeBtn = criterionEl.createEl("button", {
      text: "\xD7",
      cls: "remove-criterion-btn"
    });
    removeBtn.addEventListener("click", async () => {
      const index = this.plugin.settings.groupingCriteria.findIndex((c) => c.id === criterion.id);
      if (index !== -1) {
        this.plugin.settings.groupingCriteria.splice(index, 1);
        this.plugin.settings.groupingCriteria.forEach((c, i) => c.order = i);
        await this.plugin.saveSettings();
        this.display();
      }
    });
    criterionEl.draggable = true;
    criterionEl.addEventListener("dragstart", (e) => {
      if (e.dataTransfer) {
        e.dataTransfer.setData("text/plain", criterion.id);
      }
    });
    criterionEl.addEventListener("dragover", (e) => {
      e.preventDefault();
    });
    criterionEl.addEventListener("drop", async (e) => {
      e.preventDefault();
      if (e.dataTransfer) {
        const draggedId = e.dataTransfer.getData("text/plain");
        const draggedIndex = this.plugin.settings.groupingCriteria.findIndex((c) => c.id === draggedId);
        const targetIndex = this.plugin.settings.groupingCriteria.findIndex((c) => c.id === criterion.id);
        if (draggedIndex !== -1 && targetIndex !== -1 && draggedIndex !== targetIndex) {
          const draggedCriterion = this.plugin.settings.groupingCriteria[draggedIndex];
          this.plugin.settings.groupingCriteria.splice(draggedIndex, 1);
          this.plugin.settings.groupingCriteria.splice(targetIndex, 0, draggedCriterion);
          this.plugin.settings.groupingCriteria.forEach((c, i) => c.order = i);
          await this.plugin.saveSettings();
          this.display();
        }
      }
    });
  }
};

// main.ts
var TodoExtendedPlugin = class extends import_obsidian3.Plugin {
  async onload() {
    await this.loadSettings();
    await this.scanAvailableProperties();
    this.registerView(
      VIEW_TYPE_TODO_EXTENDED,
      (leaf) => new TodoExtendedView(leaf, this)
    );
    this.addRibbonIcon("checkmark", "Todo Extended", () => {
      this.activateView();
    });
    this.addCommand({
      id: "open-todo-extended",
      name: "Open Todo Extended View",
      callback: () => {
        this.activateView();
      }
    });
    this.addSettingTab(new TodoExtendedSettingTab(this.app, this));
    this.registerEvent(
      this.app.vault.on("modify", (file) => {
        if (file instanceof import_obsidian3.TFile) {
          this.refreshTodos();
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("create", (file) => {
        if (file instanceof import_obsidian3.TFile) {
          this.refreshTodos();
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("delete", (file) => {
        this.refreshTodos();
      })
    );
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    await this.scanAvailableProperties();
    this.refreshTodos();
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_TODO_EXTENDED);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      if (leaf) {
        await leaf.setViewState({ type: VIEW_TYPE_TODO_EXTENDED, active: true });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
  refreshTodos() {
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_TODO_EXTENDED);
    leaves.forEach((leaf) => {
      if (leaf.view instanceof TodoExtendedView) {
        leaf.view.refreshTodos();
      }
    });
  }
  async getAllTodos() {
    const files = this.app.vault.getMarkdownFiles();
    const nestedGroups = /* @__PURE__ */ new Map();
    for (const file of files) {
      if (this.settings.filterMostRecentDaily && this.isDailyNote(file)) {
        if (!this.isMostRecentDailyNote(file)) {
          continue;
        }
      }
      const content = await this.app.vault.read(file);
      const cache = this.app.metadataCache.getFileCache(file);
      const todos = this.extractTodosFromFile(file, content, cache);
      for (const todo of todos) {
        const groupKeys = this.getMultiLevelGroupKey(todo, file);
        const groupKey = groupKeys.join(" > ");
        if (!nestedGroups.has(groupKey)) {
          nestedGroups.set(groupKey, []);
        }
        nestedGroups.get(groupKey).push(todo);
      }
    }
    const groups = [];
    for (const [groupName, todos] of nestedGroups) {
      const sortedTodos = this.sortTodosWithHierarchy(todos);
      groups.push({
        name: groupName,
        todos: sortedTodos
      });
    }
    return groups.sort((a, b) => a.name.localeCompare(b.name));
  }
  sortTodosWithHierarchy(todos) {
    const byFile = /* @__PURE__ */ new Map();
    for (const todo of todos) {
      const fileKey = todo.file.path;
      if (!byFile.has(fileKey)) {
        byFile.set(fileKey, []);
      }
      byFile.get(fileKey).push(todo);
    }
    const result = [];
    for (const fileTodos of byFile.values()) {
      const sortedFileTodos = fileTodos.sort((a, b) => {
        const priorityOrder = { "high": 0, "medium": 1, "low": 2, "none": 3 };
        const priorityDiff = priorityOrder[a.priority] - priorityOrder[b.priority];
        if (priorityDiff !== 0)
          return priorityDiff;
        if (a.dueDate && b.dueDate) {
          const dateDiff = a.dueDate.diff(b.dueDate);
          if (dateDiff !== 0)
            return dateDiff;
        }
        if (a.dueDate && !b.dueDate)
          return -1;
        if (!a.dueDate && b.dueDate)
          return 1;
        return a.line - b.line;
      });
      result.push(...sortedFileTodos);
    }
    return result;
  }
  extractTodosFromFile(file, content, cache) {
    const todos = [];
    const lines = content.split("\n");
    lines.forEach((line, index) => {
      const todoMatch = line.match(/^(\s*)(- \[[ x]\])\s*(.*)$/);
      if (todoMatch) {
        const [, indent, checkbox, text] = todoMatch;
        const isCompleted = checkbox.includes("x");
        if (isCompleted && this.settings.hideCompletedTodos) {
          return;
        }
        if (text.trim() === "" && this.settings.hideBlankTodos) {
          return;
        }
        const todo = {
          id: `${file.path}:${index}`,
          text: text.trim(),
          completed: isCompleted,
          file,
          line: index,
          indent: indent.length,
          dueDate: this.extractDueDate(text),
          priority: this.extractPriority(text),
          tags: this.extractTags(text),
          properties: this.extractProperties(cache),
          originalText: line,
          linkedNotes: this.extractLinkedNotes(text),
          displayText: this.createDisplayText(text),
          images: this.extractImages(text)
        };
        todos.push(todo);
      }
    });
    return todos;
  }
  extractDueDate(text) {
    const dateFormat = this.settings.dateInputFormat;
    const dueDatePattern = this.settings.dueDateFormat.replace("%date%", `([^\\s]+)`);
    const match = text.match(new RegExp(dueDatePattern));
    if (match) {
      const dateStr = match[1];
      const parsedDate = (0, import_obsidian3.moment)(dateStr, dateFormat, true);
      if (parsedDate.isValid()) {
        return parsedDate;
      }
    }
    return null;
  }
  extractPriority(text) {
    const priorityPattern = this.settings.priorityFormat.replace("%priority%", "(high|medium|low)");
    const match = text.match(new RegExp(priorityPattern, "i"));
    if (match) {
      return match[1].toLowerCase();
    }
    return "none";
  }
  extractTags(text) {
    const tagMatches = text.match(/#[\w-]+/g);
    return tagMatches ? tagMatches.map((tag) => tag.substring(1)) : [];
  }
  extractProperties(cache) {
    return (cache == null ? void 0 : cache.frontmatter) || {};
  }
  extractLinkedNotes(text) {
    const linkMatches = text.match(/\[\[([^\]]+)\]\]/g);
    if (!linkMatches)
      return [];
    return linkMatches.map((link) => {
      const noteName = link.slice(2, -2);
      return noteName.split("|")[0];
    });
  }
  createDisplayText(text) {
    let displayText = text.replace(/\[\[([^\]]+)\]\]/g, (match, noteName) => {
      const parts = noteName.split("|");
      return parts.length > 1 ? parts[1] : parts[0];
    });
    displayText = displayText.replace(/!\[[^\]]*\]\([^)]+\)/g, "");
    displayText = displayText.replace(/!\[\[([^\]]+)\]\]/g, "");
    return displayText.trim();
  }
  extractImages(text) {
    const images = [];
    const markdownImageMatches = text.match(/!\[[^\]]*\]\(([^)]+)\)/g);
    if (markdownImageMatches) {
      markdownImageMatches.forEach((match) => {
        const pathMatch = match.match(/!\[[^\]]*\]\(([^)]+)\)/);
        if (pathMatch) {
          const imagePath = pathMatch[1];
          images.push(imagePath);
        }
      });
    }
    const wikiImageMatches = text.match(/!\[\[([^\]]+)\]\]/g);
    if (wikiImageMatches) {
      wikiImageMatches.forEach((match) => {
        const pathMatch = match.match(/!\[\[([^\]]+)\]\]/);
        if (pathMatch) {
          const imageName = pathMatch[1];
          const imageFile = this.app.vault.getFiles().find(
            (f) => f.name === imageName || f.basename === imageName
          );
          if (imageFile) {
            const resourcePath = this.app.vault.getResourcePath(imageFile);
            images.push(resourcePath);
          }
        }
      });
    }
    return images;
  }
  isDailyNote(file) {
    const datePattern = /^\d{4}-\d{2}-\d{2}$/;
    return datePattern.test(file.basename);
  }
  isMostRecentDailyNote(file) {
    const files = this.app.vault.getMarkdownFiles();
    const dailyNotes = files.filter((f) => this.isDailyNote(f));
    if (dailyNotes.length === 0)
      return false;
    dailyNotes.sort((a, b) => b.basename.localeCompare(a.basename));
    return dailyNotes[0].path === file.path;
  }
  async toggleTodo(todoId) {
    const [filePath, lineStr] = todoId.split(":");
    const line = parseInt(lineStr);
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (!(file instanceof import_obsidian3.TFile))
      return;
    const content = await this.app.vault.read(file);
    const lines = content.split("\n");
    if (line < lines.length) {
      const currentLine = lines[line];
      const newLine = currentLine.replace(/- \[[ x]\]/, (match) => {
        return match.includes("x") ? "- [ ]" : "- [x]";
      });
      lines[line] = newLine;
      await this.app.vault.modify(file, lines.join("\n"));
    }
  }
  async updateTodoDueDate(todoId, dueDate) {
    const [filePath, lineStr] = todoId.split(":");
    const line = parseInt(lineStr);
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (!(file instanceof import_obsidian3.TFile))
      return;
    const content = await this.app.vault.read(file);
    const lines = content.split("\n");
    if (line < lines.length) {
      let currentLine = lines[line];
      const dueDatePattern = this.settings.dueDateFormat.replace("%date%", "[^\\s]+");
      currentLine = currentLine.replace(new RegExp("\\s*" + dueDatePattern), "");
      if (dueDate) {
        const dueDateStr = this.settings.dueDateFormat.replace("%date%", dueDate.format(this.settings.dateInputFormat));
        currentLine = currentLine.trim() + " " + dueDateStr;
      }
      lines[line] = currentLine;
      await this.app.vault.modify(file, lines.join("\n"));
    }
  }
  async updateTodoPriority(todoId, priority) {
    const [filePath, lineStr] = todoId.split(":");
    const line = parseInt(lineStr);
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (!(file instanceof import_obsidian3.TFile))
      return;
    const content = await this.app.vault.read(file);
    const lines = content.split("\n");
    if (line < lines.length) {
      let currentLine = lines[line];
      const priorityPattern = this.settings.priorityFormat.replace("%priority%", "(high|medium|low)");
      currentLine = currentLine.replace(new RegExp("\\s*" + priorityPattern, "i"), "");
      if (priority !== "none") {
        const priorityStr = this.settings.priorityFormat.replace("%priority%", priority);
        currentLine = currentLine.trim() + " " + priorityStr;
      }
      lines[line] = currentLine;
      await this.app.vault.modify(file, lines.join("\n"));
    }
  }
  async scanAvailableProperties() {
    const files = this.app.vault.getMarkdownFiles();
    const properties = /* @__PURE__ */ new Set();
    for (const file of files) {
      const cache = this.app.metadataCache.getFileCache(file);
      if (cache == null ? void 0 : cache.frontmatter) {
        Object.keys(cache.frontmatter).forEach((key) => {
          if (key !== "position" && !key.startsWith("_")) {
            properties.add(key);
          }
        });
      }
    }
    this.settings.availableProperties = Array.from(properties).sort();
  }
  getMultiLevelGroupKey(todo, file) {
    var _a;
    const keys = [];
    for (const criterion of this.settings.groupingCriteria.filter((c) => c.enabled).sort((a, b) => a.order - b.order)) {
      let key = "";
      switch (criterion.type) {
        case "page":
          key = file.basename;
          break;
        case "folder":
          key = ((_a = file.parent) == null ? void 0 : _a.name) || "Root";
          break;
        case "tag":
          key = todo.tags.length > 0 ? `#${todo.tags[0]}` : "No Tag";
          break;
        case "property":
          if (criterion.property) {
            const propValue = todo.properties[criterion.property];
            key = propValue ? String(propValue) : `No ${criterion.property}`;
          } else {
            key = "No Property";
          }
          break;
        case "dueDate":
          key = todo.dueDate ? todo.dueDate.format("YYYY-MM-DD") : "No Due Date";
          break;
        case "priority":
          key = todo.priority === "none" ? "No Priority" : `${todo.priority.charAt(0).toUpperCase() + todo.priority.slice(1)} Priority`;
          break;
        default:
          key = "All Todos";
      }
      keys.push(key);
    }
    return keys.length > 0 ? keys : ["All Todos"];
  }
};
